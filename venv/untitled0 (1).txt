# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DmiiV6IqHH7tl965KgMNdJwvow0Ewo6s
"""

#This programm classify chroinic kidney disease using artificial neural network

import glob
import keras as k  #machine learning library
from keras.models import  Sequential, load_model  #model- Sequential
from keras.layers import Dense   #neural network dense layer(Each neuron recieves input from all the neurons in the previous layer)
import numpy as np  #num py pythton library use for numerical works
import pandas as pd  #pandas library use data manipulation and analysis
from sklearn.model_selection import train_test_split   #machine learining library
from sklearn.preprocessing import LabelEncoder,MinMaxScaler  #for lableEncoder use for converting strig in to number
import matplotlib.pyplot as plt  #use for plot our data

from google.colab import  files
uploaded= files.upload()
df=pd.read_csv('kidney_disease.csv')
df.head()

#get shape of data
df.shape

#create list of columns for informations
columns_to_retain=['sg','al','sc','hemo','pcv','pcc','rbc','age','bp','bu','sod','pot','appet','classification']  #select columns
df = df.drop([col for col in df.columns if not col in columns_to_retain], axis=1)  # filter selected columns
df = df.dropna(axis=0) # drop missing values or N/A data rows

for column in df.columns:
  if df[column].dtype ==np.number:
    continue
  df[column]=LabelEncoder().fit_transform(df[column])

df.head()

#difining X(feature set) and Y(result set)
X=df.drop(['classification'],axis=1)
Y=df['classification']

#Feature scalling using mon-max, after scalling all features lie between 1 and 0
x_scaler=MinMaxScaler()
x_scaler.fit(X)
column_name=X.columns
X[column_name]=x_scaler.transform(X)

# dvide train set and test sets( shuffle for better train set)
X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2,shuffle=True);

#build model(using sequential method)  1 input layer(13 neurons) / 1 hiddn layer(256 neurons) / 1 out put layer(onr neuron)
model=Sequential()
model.add(Dense(256, activation='relu',kernel_initializer=k.initializers.random_normal(seed=13),input_dim=len(X.columns)))
model.add(Dense(1,activation='hard_sigmoid'))

#compile model
model.compile(loss='binary_crossentropy', optimizer='adam',metrics=['accuracy'])

#train data epochs=200
history=model.fit(X_train,Y_train, epochs=120, batch_size=X_train.shape[0])

model.save('ckd.model')

#visualize model and loss accuracy
plt.plot(history.history['acc'])
plt.plot(history.history['loss'])
plt.title('Model accuracy and model')
plt.ylabel('accuracy and loss')
plt.xlabel('epoch')

print('shape of training data: ',X_train.shape)
print('shape of test data: ',X_test.shape)

pred=model.predict(X_test)
pred=[1 if y>=0.5 else 0 for y in pred]
pred

print('Original: {0}'.format(','.join(str(x) for x in Y_test)))
print('Predict: {0}'.format(','.join(str(x) for x in pred)))